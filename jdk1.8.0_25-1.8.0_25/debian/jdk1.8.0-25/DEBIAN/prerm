#!/bin/bash
RPM_INSTALL_PREFIX=/usr/java
export RPM_INSTALL_PREFIX
    #
    # Add the shell function and related variables used by the pre-uninstall.
    #
    MOST_DIGITS="[1-9]"
ALL_DIGITS="[0-9]"
COUNTING_NUMBER="${MOST_DIGITS}${ALL_DIGITS}*\|0"
VALID_NON_NUMERIC="[-_.a-zA-Z]"
VALID_CHARS="[-_.a-zA-Z0-9]"
MAJOR_RULE="\(${MOST_DIGITS}${ALL_DIGITS}*\)"
MINOR_RULE="\(${COUNTING_NUMBER}\)"
MICRO_RULE="\(${COUNTING_NUMBER}\)"
UPDATE_RULE="\(${MOST_DIGITS}${ALL_DIGITS}\|0${ALL_DIGITS}\)"
NON_FCS_ID_RULE="\([a-zA-Z0-9]*\)"
MIN_VERSION_ID_RULE="${MAJOR_RULE}\.${MINOR_RULE}\.${MICRO_RULE}"
FCS_VERSION_ID_RULE="${MIN_VERSION_ID_RULE}\(_${UPDATE_RULE}\)\?"
VERSION_ID_RULE="${FCS_VERSION_ID_RULE}\(-${NON_FCS_ID_RULE}\)\?"
NAME_ID_RULE="${VALID_CHARS}*${VALID_NON_NUMERIC}"
KNOWN_GOOD_NAME_LIST="java jdk jre j2sdk j2re"
PRS_ERROR_BAD_PARAMS=2000
expand_version() {
    status=0
    if [ $# -eq 0 ]; then
        read release remainder
        status=$?
        if [ ${status} -ne 0 ]; then
            printf "Error(${status}: failed to read!\n"         >> /dev/stderr
            status=${PRS_ERROR_BAD_PARAMS}
        elif [ -z "${release}" ]; then
            printf "Error: usage - function requires input!\n"  >> /dev/stderr
            status=${PRS_ERROR_BAD_PARAMS}
        elif [ -n "${remainder}" ]; then
            printf "Error: too many words read:\n\n"            >> /dev/stderr
            printf "\t${release} ${remainder}\n"                >> /dev/stderr
            status=${PRS_ERROR_BAD_PARAMS}
        fi
    elif [ $# -eq 1 ]; then
        release=$1
    else
        printf "Error: usage - function takes 1 parameter:\n\n" >> /dev/stderr
        printf "\t expand_version $*\n"                         >> /dev/stderr
        status=${PRS_ERROR_BAD_PARAMS}
    fi
    if [ ${status} -eq 0 ]; then
        format="%d\t%d\t%d\t%d\n"
        echo ${release} | sed -e "s/_/\./g" | \
          awk -v format="${format}" 'BEGIN { FS = "." } { printf format, $1, $2, $3, $4 }'
    fi
    return ${status}
}
parse_release() {
    status=0
    if [ $# -eq 0 ]; then
        read string remainder
        status=$?
        if [ ${status} -ne 0 ]; then
            printf "Error(${status}: failed to read!\n"         >> /dev/stderr
            status=${PRS_ERROR_BAD_PARAMS}
        elif [ -z "${string}" ]; then
            printf "Error: usage - function requires input!\n"  >> /dev/stderr
            status=${PRS_ERROR_BAD_PARAMS}
        elif [ -n "${remainder}" ]; then
            printf "Error: too many words read:\n\n"            >> /dev/stderr
            printf "\t${string} ${remainder}\n"                 >> /dev/stderr
            status=${PRS_ERROR_BAD_PARAMS}
        fi
    elif [ $# -eq 1 ]; then
        string=$1
    else
        printf "Error: usage - function takes 1 parameter:\n\n" >> /dev/stderr
        printf "\t parse_release $*\n"                          >> /dev/stderr
        status=${PRS_ERROR_BAD_PARAMS}
    fi
    if [ ${status} -eq 0 ]; then
        version_id=`expr "${string}" : "${NAME_ID_RULE}\(${VERSION_ID_RULE}\)\$"`
        if [ -n "${version_id}" ]; then
            name_id=`expr "${string}" : "\(${NAME_ID_RULE}\)${VERSION_ID_RULE}\$"`
            fcs_part=`expr "${string}" : "${NAME_ID_RULE}\(${FCS_VERSION_ID_RULE}\).*\$"`
            non_fcs_part=`expr "${version_id}" : "[^-]*-\(${NON_FCS_ID_RULE}\)\$"`
            printf "${name_id}\t${fcs_part}\t${non_fcs_part}\n"
        fi
    fi
    return ${status}
}
UNKNOWN_NAME_WEIGHT=1000
get_name_weight() {
    status=0
    if [ "$1" = "-" ]; then
        read name good_names
        status=$?
        if [ ${status} -ne 0 ]; then
            printf "Error(${status}: failed to read!\n"                >> /dev/stderr
            status=${PRS_ERROR_BAD_PARAMS}
        else
            shift 1
            if [ $# -gt 0 ]; then
                good_names="$*"
            fi
            if [ -z "${name}" ]; then
                printf "Error: usage - function requires input!\n"     >> /dev/stderr
                status=${PRS_ERROR_BAD_PARAMS}
            fi
        fi
    elif [ $# -gt 1 ]; then
        name=$1
        shift 1
        good_names="$*"
    else
        printf "Error: usage - function takes 2+ parameters:\n\n"      >> /dev/stderr
        printf "\t get_name_weight $*\n"                               >> /dev/stderr
        status=${PRS_ERROR_BAD_PARAMS}
    fi
    if [ ${status} -eq 0 ]; then
        if [ -n "${good_names}" ]; then
            length=`expr length "${good_names}"`
            pos=`expr "${good_names}" : ".*\<${name}\>"`
            if [ ${pos} -gt 0 ]; then
                expr substr "${good_names}" 1 ${pos} | wc -w | tr -d "[:space:]"
            else
                echo ${UNKNOWN_NAME_WEIGHT}
            fi
        else
            echo ${UNKNOWN_NAME_WEIGHT}
        fi
    fi
    return ${status}
}
HAS_FCS_WEIGHT=0
HAS_ODD_FCS_WEIGHT=1
HAS_RC_WEIGHT=100
HAS_ODD_RC_WEIGHT=101
HAS_BETA_WEIGHT=300
HAS_ODD_BETA_WEIGHT=301
HAS_EA_WEIGHT=500
HAS_ODD_EA_WEIGHT=501
HAS_INTRNAL_WEIGHT=2000
HAS_VERY_ODD_WEIGHT=9999
get_non_fcs_weight() {
    status=0
    if [ $# -eq 0 ]; then
        read non_fcs_part remainder
        status=$?
        if [ ${status} -ne 0 ]; then
            printf "Error(${status}: failed to read!\n"         >> /dev/stderr
            status=${PRS_ERROR_BAD_PARAMS}
        elif [ -n "${remainder}" ]; then
            printf "Error: too many words read:\n\n"            >> /dev/stderr
            printf "\t${non_fcs_part} ${remainder}\n"           >> /dev/stderr
            status=${PRS_ERROR_BAD_PARAMS}
        fi
    elif [ $# -eq 1 ]; then
        non_fcs_part=$1
    else
        printf "Error: usage - function takes 1 parameter:\n\n" >> /dev/stderr
        printf "\t get_non_fcs_weight $*\n"                     >> /dev/stderr
        status=${PRS_ERROR_BAD_PARAMS}
    fi
    if [ ${status} -eq 0 ]; then
        if [ -z "${non_fcs_part}" ]; then
            echo ${HAS_FCS_WEIGHT}
        else
            case "${non_fcs_part}" in
                fcs)
                    echo ${HAS_ODD_FCS_WEIGHT}
                    ;;
                rc)
                    echo ${HAS_RC_WEIGHT}
                    ;;
                rc[0-9] | rc[0-9][0-9])
                    count=`expr "${non_fcs_part}" : "rc\([0-9]*\)$"`
                    echo `expr ${HAS_RC_WEIGHT} - ${count}`
                    ;;
                rc*)
                    echo ${HAS_ODD_RC_WEIGHT}
                    ;;
                beta)
                    echo ${HAS_BETA_WEIGHT}
                    ;;
                beta[0-9] | beta[0-9][0-9])
                    count=`expr "${non_fcs_part}" : "beta\([0-9]*\)$"`
                    echo `expr ${HAS_BETA_WEIGHT} - ${count}`
                    ;;
                beta*)
                    echo ${HAS_ODD_BETA_WEIGHT}
                    ;;
                ea)
                    echo ${HAS_EA_WEIGHT}
                    ;;
                ea[0-9] | ea[0-9][0-9])
                    count=`expr "${non_fcs_part}" : "ea\([0-9]*\)$"`
                    echo `expr ${HAS_EA_WEIGHT} - ${count}`
                    ;;
                ea*)
                    echo ${HAS_ODD_EA_WEIGHT}
                    ;;
                internal)
                    echo ${HAS_INTRNAL_WEIGHT}
                    ;;
                internal[0-9] | internal[0-9][0-9] | internal[0-9][0-9][0-9])
                    count=`expr "${non_fcs_part}" : "internal\([0-9]*\)$"`
                    echo `expr ${HAS_INTRNAL_WEIGHT} - ${count}`
                    ;;
                b[0-9] | b[0-9][0-9] | b[0-9][0-9][0-9])
                    count=`expr "${non_fcs_part}" : "b\([0-9]*\)$"`
                    echo `expr ${HAS_INTRNAL_WEIGHT} - ${count}`
                    ;;
                *)
                    echo ${HAS_VERY_ODD_WEIGHT}
                    ;;
            esac
        fi
    fi
    return ${status}
}
    get_path_weight() {
    good_list="$1"
    path=$2
    release=`basename ${path}`
    parts="`parse_release ${release}`"
    if [ $? -eq 0 ]; then
        name=`echo "${parts}" | cut -f1`
        version=`echo "${parts}" | cut -f2`
        non_fcs=`echo "${parts}" | cut -f3`
        if [ -n "${version}" ]; then
           v_weight=`echo ${version} | expand_version`
           n_weight=`echo ${name} | get_name_weight - "${good_list}"`
           o_weight=`echo ${non_fcs} | get_non_fcs_weight`
           printf "%4d  %4d  %4d  %4d  %4d  %4d  %s\n" \
                  ${v_weight} ${n_weight} ${o_weight} "${path}"
        fi
    fi
}
get_weighted_list() {
    good_list=
    verify=
    stdio=
    status=0
    check=true
    while [ -n "${check}" ]; do
        if [ $# -gt 0 ]; then
            case "$1" in
                -g)
                    good_list="$2"
                    shift 2
                    ;;
                --good-list=*)
                    length=`expr length "$1"`
                    remove=`expr \( length "--good-list=" \) + 1`
                    good_list="`expr substr \"$1\" ${remove} ${length}`"
                    shift 1
                    ;;
                -v | --verify)
                    verify=true
                    shift 1
                    ;;
                --)
                    shift 1
                    check=
                    ;;
                -)
                    shift 1
                    stdio=true
                    ;;
                -*)
                    printf "Error: usage - unknown parameter:\n\n" \ 
                                                                >> /dev/stderr 
                    printf "\t%s : %s\n" "$1" "$*"              >> /dev/stderr 
                    status=${PRS_ERROR_BAD_PARAMS}
                    check=
                    ;;
                *)
                    check=
                    ;;
            esac
        else
            check=
        fi
    done
    if [ $# -eq 0 ] || [ -n "${stdio}" ]; then
        read line
        while [ -n "${line}" ]; do
            if [ -z "${verify}" ] || [ -f ${line}/bin/java ]; then
                get_path_weight "${good_list}" ${line}
            fi
            read line
        done
    fi
    while [ $# -gt 0 ]; do
        if [ -z "${verify}" ] || [ -f $1/bin/java ]; then
            get_path_weight "${good_list}" $1
        fi
        shift 1
    done
    return ${status}
}
_compare_java_by_weight() {
    compare=0
    if [ $# -ne 0 ]; then
        if [ $# -eq 1 ]; then
            compare=1
        else
            left=$1
            right=$2
            shift 2
            good="$*"
            list=`get_weighted_list --good-list="${good}" \
                    ${left} ${right} | sort -u -k1n -k2n -k3n -k4n -k5rn -k6rn`
            if [ `echo "${list}" | wc -l | tr -d "[:space:]"` -ne 1 ]; then
                compare=-1
                latest=`echo "${list}" | tail -n 1 | cut -c 37-`
                if [ "${left}" = "${latest}" ]; then
                    compare=1
                fi
            fi
        fi
    fi
    echo ${compare}
}
compare_java_by_version() {
    _compare_java_by_weight $1 $2
}
compare_java_by_release() {
    _compare_java_by_weight $1 $2 ${KNOWN_GOOD_NAME_LIST}
}
find_latest_release() {
    if [ -d /usr/java ]; then
        latest_release=`find /usr/java/* -prune | \
            get_weighted_list -v --good-list="${KNOWN_GOOD_NAME_LIST}" | \
            sort -k1n -k2n -k3n -k4n -k5rn -k6rn | tail -n 1 | cut -c 37-`
    fi
    if [ -d "${RPM_INSTALL_PREFIX}" ] && \
       [ "/usr/java" != "${RPM_INSTALL_PREFIX}" ]
    then 
        prefix_release=`find ${RPM_INSTALL_PREFIX}/* -prune | \
            get_weighted_list -v --good-list="${KNOWN_GOOD_NAME_LIST}" | \
            sort -k1n -k2n -k3n -k4n -k5rn -k6rn | tail -n 1 | cut -c 37-`
        if [ `compare_java_by_release ${latest_release} ${prefix_release}` -lt 0 ]; then
            latest_release=${prefix_release}
        fi
    fi
    echo ${latest_release}
}
get_javaws() {
    path=$1
    if [ `compare_java_by_version ${path} version-1.5.0` -ge 0 ] &&
       [ -f ${path}/bin/javaws ]
    then
        path=${path}/bin/javaws
    elif [ `compare_java_by_version ${path} version-1.4.2` -ge 0 ]; then
        if [ -f ${path}/jre/javaws/javaws ]; then
            path=${path}/jre/javaws/javaws
        elif [ -f ${path}/javaws/javaws ]; then
            path=${path}/javaws/javaws
        else
            path=
        fi
    else
        path=
    fi
    echo ${path}
}
    LINK_ERROR_BAD_PARAMS=3000
LINK_ERROR_DEAD_LINK=3001
LINK_ERROR_FILE_NOT_FOUND=3002
dereference() {
    status=0
    if [ "$1" = "-f" ] || [ "$1" = "--follow" ]; then
        follow="--follow"
        shift 1
    fi
    if [ $# -ge 1 ]; then
        path="$*"
        if [ -e "${path}" ]; then
            parent="`cd \`dirname \"${path}\"\`; pwd`"
            child="`basename \"${path}\"`"
            if [ "${parent}" != "${child}" ]; then
                path="${parent}/${child}"
            fi
            if [ -h "${path}" ]; then
                path=`ls -l "${path}" | sed -e "s#^.*${path} -> ##"`
                if [ "`expr substr \"${path}\" 1 1`" != "/" ]; then
                    path="${parent}/${path}"
                fi
                if [ -n "${follow}" ]; then
                    path="`dereference ${follow} ${path}`"
                fi                    
            fi
        else
            status=${LINK_ERROR_FILE_NOT_FOUND}
        fi
    fi
    echo ${path}
    return ${status}
}
setup_latest_link() {
    latest=$1
    link=$2
    if [ -h "${link}" ]; then
        reference="`dereference --follow ${link}`"
        if [ $? -eq 0 ]; then
            update=`compare_java_by_release "${latest}" "${reference}"`
        else
            update=1
        fi
        if [ ${update} -gt 0 ]; then
            rm -f "${link}"
        fi
    fi
    if [ ! -e "${link}" ]; then
        ln -s "${latest}" "${link}"
    fi
}
setup_default_links() {
    if [ $# -ge 2 ]; then
        latest_link="$1"
        default_link="$2"
        if [ ! -e "${default_link}" ]; then
            ln -s "${latest_link}" "${default_link}"
        fi
    fi
    if [ $# -gt 3 ]; then
        bindir="$3"
        shift 3
        for file in $*; do
            reference="`dereference --follow ${bindir}/${file}`"
            if [ $? -ne 0 ]; then
                rm -f "${bindir}/${file}"
            fi
            source="${default_link}/bin/${file}"
            if [ "${file}" = "javaws" ]; then
                source="`get_javaws \"${default_link}\"`"
            fi
            if [ -n "${source}" ] && [ ! -e "${bindir}/${file}" ]; then
                ln -s "${source}" "${bindir}/${file}"
            fi
        done
    fi
}
cleanup_default_links() {
    if [ $# -ge 1 ]; then
        default_link=$1
        if [ $# -gt 2 ]; then
            bindir="$2"
            shift 2
            for file in $*; do
                reference="`dereference \"${bindir}/${file}\"`"
                if [ $? -ne 0 ] ||
                   [ "${reference}" = "${default_link}/bin/${file}" ]
                then
                    rm -f "${bindir}/${file}"
                fi
            done
        fi
        rm -f "${default_link}"
    fi
}

    #
    # Dereference and follow any links that might have been created when this
    # package was installed.  If a link ultimately points to this installation
    # or the link is dead, then we should remove the link.  Important links,
    # like default and latest can be remade in post-uninstall (%postun).
    #
    # This is done in the reverse order the links were initially created in, in
    # case there are any partial loops.
    #
    if [ -h "/usr/java/default" ]; then
        DEFAULT_LINK="`dereference --follow \"/usr/java/default\"`"
        if [ $? -ne 0 ] ||
           [ "${DEFAULT_LINK}" = "${RPM_INSTALL_PREFIX}/jdk1.8.0_25" ]
        then
            cleanup_default_links "/usr/java/default" \
                                  "/usr/bin" java javaws jcontrol javac jar javadoc
        fi
    fi

    #
    # If the latest link still points to this installation it must mean one of
    # the following:
    #
    #     * No newer version of Java has been installed.  This is known because
    #       any such version would have already changed the latest to point
    #       to itself.
    #
    #     * No older version is installed.  We don't check this now, but if this
    #       is the case, now is the best time to remove the latest link, since
    #       anything pointing to this installation in post-uninstall will be a
    #       dead link.
    #
    #     * There is an older version of Java installed.  In this case we need
    #       to handle the latest link differently depending on what version
    #       remains.
    #
    if [ -h "/usr/java/latest" ]; then
        LATEST_LINK="`dereference --follow \"/usr/java/latest\"`"
        if [ $? -ne 0 ] ||
           [ "${LATEST_LINK}" = "${RPM_INSTALL_PREFIX}/jdk1.8.0_25" ]
        then
            #
            # If this version is the latest, and the first version with jexec
            # support, then stop and remove the jexec service.  If this isn't
            # done now, there might not be an init script left when %postun is
            # called, and if there is, we can restart/reinstall the service
            # easy enough then.
            #
            if [ `compare_java_by_version ${LATEST_LINK} \
                                  version-1.6.0` -ge 0 ] &&
               [ -x /usr/java/jdk1.8.0_25/.java/init.d/jexec ]
            then
                /usr/java/jdk1.8.0_25/.java/init.d/jexec stop > /dev/null 2>&1

                if [ -x /usr/lib/lsb/remove_initd ]; then
                    /usr/lib/lsb/remove_initd jexec > /dev/null 2>&1
                elif [ -x /sbin/chkconfig ]; then
                    /sbin/chkconfig --del jexec > /dev/null 2>&1
                fi
            fi

            rm -f "/usr/java/latest" 2> /dev/null
        fi
    fi

    #
    # If the package was relocated when it was installed, there should be a link
    # in /usr/java.  So, if there is a link named /usr/java/jdk1.8.0_25 that is
    # dead, or points back to ${RPM_INSTALL_PREFIX}, delete it.
    #
    if [ "${RPM_INSTALL_PREFIX}" != "/usr/java" ] &&
       [ -h "/usr/java/jdk1.8.0_25" ]
    then
        THIS_LINK="`dereference --follow \"/usr/java/jdk1.8.0_25\"`"
        if [ $? -ne 0 ] ||
           [ "${THIS_LINK}" = "${RPM_INSTALL_PREFIX}/jdk1.8.0_25" ]
        then
            rm -f "/usr/java/jdk1.8.0_25" 2> /dev/null
        fi
    fi